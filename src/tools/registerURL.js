/*
 * Copyright (c) 2014 Juniper Networks, Inc. All rights reserved.
 */

/* This file uses pareseURL.xml and creates the file urlRoutes.api.js */
var fs = require('fs'),
    xml2js = require('xml2js'),
    assert = require('assert');

var urlLists = [];

function parseURLFile (result, fileToGen, cb)
{
  var itemList = result['urlLists']['item'];
  var urlCbStr = "";
  var commentStr = "";
  var method;
  var timeout;
  var capStr = "";
  var callback;
  var longPollStr = "";
  var longPollArrStr = "";

  commentStr += "/*\n";
  commentStr += " * Copyright (c) 2014 Juniper Networks, Inc. All rights reserved.\n";
  commentStr += " */\n";
  commentStr += "\n";
  var date = new Date();
  commentStr +=  "/* This file is automatically generated from the parseURL.xml at\n"
  commentStr += "   " + date;
  commentStr += "\n";
  commentStr += "   Please do not edit this file."
  commentStr += "\n"
  commentStr += " */";
  commentStr += "\n";
  commentStr += "\n";

  urlCbStr += commentStr;
  var requiresList = result['urlLists']['require'];
  var len = 0;
  if (requiresList) {
    len = requiresList.length;
  }
  for (var i = 0; i < len; i++) {
      var splitter = (requiresList[i]['path']).toString().split('+');
      if (i == 0) {
         if ((requiresList[i] == null) || (null == requiresList[i]['define']) ||
             (null == requiresList[i]['path'])) {
             assert(0);
         }
         urlCbStr += 'var ' + requiresList[i]['define'] + ' = require(';
         if (splitter.length <= 1) {
             urlCbStr += "'" + requiresList[i]['path'] + "')\n";
         } else {
             urlCbStr += requiresList[i]['path'] +")\n";
         }
         continue;
      }
      urlCbStr += '  , ' + requiresList[i]['define'] + ' = require(';
      if (splitter.length <= 1) {
          urlCbStr += "'" + requiresList[i]['path'] + "')\n";
      } else {
          urlCbStr += requiresList[i]['path'] + ")\n";
      }
  }
  urlCbStr += "  ;\n";

  urlCbStr += "\n";
  urlCbStr += "\n";
  urlCbStr += "if (!module.parent) {";
  urlCbStr += "\n  console.log(\"Call main app through 'node app'\");";
  urlCbStr += "\n  process.exit(1);";
  urlCbStr += "\n}";
  urlCbStr += "\n";
  urlCbStr += "urlRoutes = module.exports;";
  urlCbStr += "\n";
  urlCbStr += "\n" +
  '/* Default handler for request timeout */\n' +
  'function defHandleReqTimeout (req, res)\n' +
  '{\n' +
  '  var str = ' + '"Request timed out: URL::" + req.url;\n' +
  '  if (req.pubChannel) {\n' + 
  '    /* Delete the Req Pending Q Entry */\n' +
  '    parseURLReq.cacheApi.deleteCachePendingQueueEntry(req.pubChannel);\n' +    
  '  };\n' +
  '  res.req.invalidated = true;\n' +
  '  res.send(parseURLReq.global.HTTP_STATUS_GATEWAY_TIMEOUT, str);\n' +
  '}\n' +
  '\n';
  
  urlCbStr += "urlRoutes.registerURLsToApp = function(app) {\n";

  commentStr = "";
  commentStr = "/* Register the URL with callback */\n";
  urlCbStr += commentStr;

  len = 0;
  if (itemList) {
    len = itemList.length;
  }
  for (var i = 0; i < len; i++) {
    timeout = null;
    /* register URLs */
    urlCbStr += "  app.";
    method = itemList[i]['method'];
    if (method == 'get') {
      urlCbStr += "get(";
    } else if (method == 'put') {
      urlCbStr += "put(";
    } else if (method == 'post') {
      urlCbStr += "post(";
    } else if (method == 'delete') {
      urlCbStr += "delete(";
    } else {
      /* Unknown method */
      assert(0);
    }
    callback = "'" + itemList[i]['callback'] ;
    /* Callback is always written as moduleName.my_callback, so here idea is write
     * one more wraper function in this file named as my_callback and there call
     * moduleName.my_callback, and in API my_callback, do store the data for
     * longpolling
     */

    var pos = callback.indexOf(".");
    if (pos == -1) {
      assert(0);
    }
   
    longPollArrStr += callback.substr(1, pos - 1) + "_" + callback.slice(pos + 1) + 
      " = function(req, res, next) {\n";
    longPollArrStr += "  /* Check if this request needs to be added in \n";
    longPollArrStr += "     pendingQ \n";
    longPollArrStr += "   */\n";
    longPollArrStr += "  var reqCtx = parseURLReq.longPoll.routeAll(req, res, next);\n";
    longPollArrStr += "  if (null == reqCtx) {\n";
    longPollArrStr += "    /* either not a valid URL, or unAuthed session */\n";
    longPollArrStr += "  } else {\n";
    longPollArrStr += "    /* Set the request timeout */\n";
    timeout = itemList[i]['timeout'];
    if (null != timeout) {
      timeout = parseInt(timeout);
    }
    longPollArrStr += "    parseURLReq.timeout(req, res, ";
    if (null != timeout) {
      longPollArrStr += parseInt(itemList[i]['timeout']) + ");\n";
    } else {
      longPollArrStr += "parseURLReq.global.DFLT_HTTP_REQUEST_TIMEOUT_TIME);\n";
    }
    longPollArrStr += "    req.once('timeout', ";
    if (null != itemList[i]['timeoutCallback']) {
      longPollArrStr += itemList[i]['timeoutCallback'] + ");\n";
    } else {
      longPollArrStr += 'defHandleReqTimeout);\n';
    }
    longPollArrStr += "    /* Now process the resuest */\n";
    longPollArrStr += "    parseURLReq.longPoll.processPendingReq(reqCtx, next, " +
      itemList[i]['callback'] + ");\n";
    longPollArrStr += "  }\n";
    longPollArrStr += "}\n";

      
    urlCbStr += "'" + itemList[i]['url'] + "', " + 
      callback.substr(1, pos - 1) + "_" + callback.slice(pos + 1) + ");\n";
 
    /* Register feature string with URL */
    capStr += "  parseURLReq.rbac.setFeatureByURL(" + "'" + itemList[i]['url'] + "'";
    capStr += ", " + "'" + method + "'" + ", " + "app.routes, " + "'" +
      itemList[i]['feature'] + "'" + ");\n";
  }
  urlCbStr += "\n";
  urlCbStr += "\n";
    
  urlCbStr += capStr;
  urlCbStr += "}\n";

  urlCbStr += longPollArrStr;
  fs.writeFile(fileToGen, urlCbStr, function(err) {
    if (err) throw err;
    console.log("Done, creating file: " + fileToGen);
    cb(err);
  });
}

/*
var args = process.argv.slice(2);
var parser = new xml2js.Parser();
parser.addListener('end', function(result) {
    var fileToGen = null;
    if ('base' == args[0]) {
        fileToGen = __dirname + '/../serverroot/web/routes/url.routes.base.js';
    } else {
        fileToGen = __dirname + '/../serverroot/web/routes/url.routes.js';
    }
    parseURLFile(result, fileToGen);
});


var parseFile = null;
if ('base' == args[0]) {
    parseFile = '../xml/parseURLBase.xml';
} else {
    parseFile = '../xml/parseURL.xml';
}
fs.readFile(__dirname + '/' + parseFile, function(err, data) {
    parser.parseString(data);
});
*/
exports.parseURLFile = parseURLFile;

